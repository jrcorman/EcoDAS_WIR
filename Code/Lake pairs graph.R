#### Lake Pairs Analysis ####
# code generated by jrc     #
# data generated by ks      #
#############################

lp <- read.csv("Data/NLA_lakepairs_50km.csv")
names(lp)
# Columns 1 - 63 include reservoir info
# Columns 64 - 138 include lake info

# Add identifier for pairs
lp$pairs <- seq(1:66)

# Reservoirs of interest
res <- cbind(lp$pairs, as.character(lp$ManMadeSITE_ID))
res <- as.data.frame(res)
# list of res names
res.names <- unique(res[,2])

# Lakes of interest
lakes <- cbind(lp$pairs, as.character(lp$SITE_ID))
lakes <- as.data.frame(lakes)
# list of lake names
lakes.names <- unique(lakes[,2])

pairs <- rbind(res, lakes)
colnames(pairs) <- c("PAIR_ID", "SITE_ID")

# What is different between man-made and natural lakes using pairs within
# 50 km?

# Part 1. secchi disk depth
secchi <- read.csv("Data/NLA2007_secchi.csv") #secchi data

res.secchi <- subset(secchi, SITE_ID %in% res.names)
lakes.secchi <- subset(secchi, SITE_ID %in% lakes.names)

# there are multiple records of secchi for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.secmean <- ddply(res.secchi, .(SITE_ID), summarize,
                     secmean = mean(SECMEAN))
res.secmean$type <- rep("reservoir")
lakes.secmean <- ddply(lakes.secchi, .(SITE_ID), summarize,
                      secmean = mean(SECMEAN))
lakes.secmean$type <- rep("lakes")

# combine secchi datasets into one long dataframe
secmean <- rbind(res.secmean, lakes.secmean)

# Combine all info into one dataframe
sdata <- merge(pairs, secmean, by="SITE_ID")

# Cast data to wide for stats comparisons
sdata.wide <- dcast(sdata, PAIR_ID ~ type, value.var = "secmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
sdata.wide$x <- sdata.wide$lakes - sdata.wide$reservoir
boxplot(sdata.wide$x)
qqnorm(sdata.wide$x)
qqline(sdata.wide$x)
# outlier in the data, drop from dataset
sdata.out <- sdata.wide[(sdata.wide$x < 30), ]
# Now, check
boxplot(sdata.out$x)
qqnorm(sdata.out$x)
qqline(sdata.out$x)
shapiro.test(sdata.out$x) # still not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(sdata.out$lakes, sdata.out$reservoir, paired=TRUE)
# V = 1225, p-value = 0.00014

# Now, plot! 
library(ggplot2)
# first, prep the data
sdata.long <- melt(sdata.out[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="secmean")
sdata.long <- sdata.long[complete.cases(sdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
sec.plot <- ggplot(sdata.long, aes(x=type, y=secmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Secchi Depth (m)") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
sec.plot +   annotate(geom = "text", label = "p < 0.001", x=2, y=15, size=4)


##################################################
# temperature (more difficult to interpret, tho) #
##################################################

# Part 1. secchi disk depth
temp <- read.csv("Data/NLA2007_temp.csv") #temp data
temp1 <- subset(temp, DEPTH == 5) # select only 5 m depth

res.temp<- subset(temp1, SITE_ID %in% res.names)
lakes.temp <- subset(temp1, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.tempmean <- ddply(res.temp, .(SITE_ID), summarize,
                     tempmean = mean(TEMP_FIELD))
res.tempmean$type <- rep("reservoir")
lakes.tempmean <- ddply(lakes.temp, .(SITE_ID), summarize,
                       tempmean = mean(TEMP_FIELD))
lakes.tempmean$type <- rep("lakes")

# combine temp datasets into one long dataframe
ctemp <- rbind(res.tempmean, lakes.tempmean)

# Combine all info into one dataframe
tdata <- merge(pairs, ctemp, by="SITE_ID")

# Cast data to wide for stats comparisons
tdata.wide <- dcast(tdata, PAIR_ID ~ type, value.var = "tempmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
tdata.wide$x <- tdata.wide$lakes - tdata.wide$reservoir
boxplot(tdata.wide$x)
qqnorm(tdata.wide$x)
qqline(tdata.wide$x)
shapiro.test(tdata.wide$x) 
# Normally distributed, so using a t-distribution

t.test(tdata.wide$lakes, tdata.wide$reservoir, paired=TRUE)
# t = -0.72529, df = 54, p-value = 0.4715 (for 1 m depth)
# t = -0.97688, df = 18, p = 0.3416 (for 5 m depth)

# Now, plot! 
library(ggplot2)
# first, prep the data
tdata.long <- melt(tdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="tempmean")
tdata.long <- tdata.long[complete.cases(tdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
t.plot <- ggplot(tdata.long, aes(x=type, y=tempmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Temperature (oC)") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
t.plot +   annotate(geom = "text", label = "p < 0.4715", x=2.15, y=15, size=4)

########################################
# Catchment area : lake area- boxplots #
########################################

basin <- read.csv("Data/NLA2007_basin.csv")
area <- read.csv("Data/NLA2007_lakes.csv")
catch <- merge(basin, area, by = "SITE_ID") # only merges if SITE_ID is in both files

res.catch<- subset(catch, SITE_ID %in% res.names)
res.catch$type <- rep("reservoir")
lakes.catch <- subset(catch, SITE_ID %in% lakes.names)
lakes.catch$type <- rep("lake")

# combine temp datasets into one long dataframe
c.catch <- rbind(res.catch, lakes.catch)

# Combine all info into one dataframe
cdata <- merge(pairs, c.catch, by="SITE_ID")
cdata$CA_LA <- cdata$BASINAREA_KM2/cdata$LAKEAREA # lake area in km^2

# Cast data to wide for stats comparisons
# Using average here because some lakes listed multiple times.
cdata.wide <- dcast(cdata, PAIR_ID ~ type, value.var = "CA_LA", fun.aggregate = mean)

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
cdata.wide$x <- cdata.wide$lake - cdata.wide$reservoir
hist(cdata.wide$x)
boxplot(cdata.wide$x)
qqnorm(cdata.wide$x)
qqline(cdata.wide$x)
shapiro.test(cdata.wide$x) 
# Not-Normally distributed
# Wilcoxon Signed Rank Test
wilcox.test(cdata.wide$lake, cdata.wide$reservoir, paired=TRUE)
# V = 742, p-value = 0.0204

# Now, plot! 
library(ggplot2)
# first, prep the data
cdata.long <- melt(cdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="CA_LAratio")
cdata.long <- cdata.long[complete.cases(cdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
tapply(X = cdata.long$CA_LAratio, INDEX = cdata.long$type, FUN = mean)
c.plot <- ggplot(cdata.long, aes(x=type, y=CA_LAratio, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Catchment Area : Lake Area") +
  scale_x_discrete(breaks = c("lake", "reservoir"), 
                   labels = c("natural", "human made")) +
  scale_y_log10()
c.plot +   annotate(geom = "text", label = "p < 0.05", x=2.15, y=15, size=4)

##############################################################
# scatter plot of secchi disk by catchment area : lake area  #
# with distintion between man-made and natural lake          #
##############################################################

# Merge needed data files
sec_CALA <- merge(secchi, catch, by = "SITE_ID")

# Subset pairs of lakes and add identifier
res.sc<- subset(sec_CALA, SITE_ID %in% res.names)
res.sc$type <- rep("reservoir")
lakes.sc <- subset(sec_CALA, SITE_ID %in% lakes.names)
lakes.sc$type <- rep("lake")

# combine datasets into one long dataframe
sc.catch <- rbind(res.sc, lakes.sc)

# Combine all info into one dataframe
scdata <- merge(pairs, sc.catch, by="SITE_ID")
scdata$CA_LA <- scdata$BASINAREA_KM2/scdata$LAKEAREA # lake area in km^2

# ANOVA of Secchi and CA_LA across all sites
library(lme4)
mod <- lmer(SECMEAN ~ CA_LA + (1|PAIR_ID), data=scdata)
summary(mod)
anova(mod)

# Now, plot! 
library(ggplot2)
sc.plot <- ggplot(scdata, aes(x=CA_LA, y=SECMEAN, group=PAIR_ID)) +
  geom_point() +
  theme_classic(14) +
  scale_y_log10() +
  scale_x_log10() +
  geom_line(alpha=0.5)
sc.plot 

