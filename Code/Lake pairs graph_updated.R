#### Lake Pairs Analysis ####
# code generated by jrc     #
# data generated by ks      #
# additional code by brd    #
#############################

lp <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA_lakepairs_50km.csv")
names(lp)
# Columns 1 - 63 include reservoir info
# Columns 64 - 138 include lake info

# Add identifier for pairs
lp$pairs <- seq(1:66)

# Reservoirs of interest
res <- cbind(lp$pairs, as.character(lp$ManMadeSITE_ID))
res <- as.data.frame(res)
# list of res names
res.names <- unique(res[,2])

# Lakes of interest
lakes <- cbind(lp$pairs, as.character(lp$SITE_ID))
lakes <- as.data.frame(lakes)
# list of lake names
lakes.names <- unique(lakes[,2])

pairs <- rbind(res, lakes)
colnames(pairs) <- c("PAIR_ID", "SITE_ID")

# What is different between man-made and natural lakes using pairs within
# 50 km?

# Part 1. secchi disk depth
secchi <- read.csv("Data/NLA2007_secchi.csv") #secchi data

res.secchi <- subset(secchi, SITE_ID %in% res.names)
lakes.secchi <- subset(secchi, SITE_ID %in% lakes.names)

# there are multiple records of secchi for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.secmean <- ddply(res.secchi, .(SITE_ID), summarize,
                     secmean = mean(SECMEAN))
res.secmean$type <- rep("reservoir")
lakes.secmean <- ddply(lakes.secchi, .(SITE_ID), summarize,
                      secmean = mean(SECMEAN))
lakes.secmean$type <- rep("lakes")

# combine secchi datasets into one long dataframe
secmean <- rbind(res.secmean, lakes.secmean)

# Combine all info into one dataframe
sdata <- merge(pairs, secmean, by="SITE_ID")

# Cast data to wide for stats comparisons
sdata.wide <- dcast(sdata, PAIR_ID ~ type, value.var = "secmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
sdata.wide$x <- sdata.wide$lakes - sdata.wide$reservoir
boxplot(sdata.wide$x)
qqnorm(sdata.wide$x)
qqline(sdata.wide$x)
# outlier in the data, drop from dataset
sdata.out <- sdata.wide[(sdata.wide$x < 30), ]
# Now, check
boxplot(sdata.out$x)
qqnorm(sdata.out$x)
qqline(sdata.out$x)
shapiro.test(sdata.out$x) # still not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(sdata.out$lakes, sdata.out$reservoir, paired=TRUE)
# V = 1225, p-value = 0.00014
mean(sdata.out$lakes)

# Now, plot! 
library(ggplot2)
# first, prep the data
sdata.long <- melt(sdata.out[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="secmean")
sdata.long <- sdata.long[complete.cases(sdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
sec.plot <- ggplot(sdata.long, aes(x=type, y=secmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Secchi Depth (m)") +
  xlab("") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
secchip<-sec.plot +   annotate(geom = "text", label = "p < 0.001", x=1.5, y=17, size=4)


##################################################
# temperature (more difficult to interpret, tho) #
##################################################

# Part 1. temperatures
temp <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_temp.csv") #temp data
temp1 <- subset(temp, DEPTH == 1) # select only 1 m depth

res.temp<- subset(temp1, SITE_ID %in% res.names)
lakes.temp <- subset(temp1, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.tempmean <- ddply(res.temp, .(SITE_ID), summarize,
                     tempmean = mean(TEMP_FIELD))
res.tempmean$type <- rep("reservoir")
lakes.tempmean <- ddply(lakes.temp, .(SITE_ID), summarize,
                       tempmean = mean(TEMP_FIELD))
lakes.tempmean$type <- rep("lakes")

# combine temp datasets into one long dataframe
ctemp <- rbind(res.tempmean, lakes.tempmean)

# Combine all info into one dataframe
tdata <- merge(pairs, ctemp, by="SITE_ID")

# Cast data to wide for stats comparisons
tdata.wide <- dcast(tdata, PAIR_ID ~ type, value.var = "tempmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
tdata.wide$x <- tdata.wide$lakes - tdata.wide$reservoir
boxplot(tdata.wide$x)
qqnorm(tdata.wide$x)
qqline(tdata.wide$x)
shapiro.test(tdata.wide$x) 
# Normally distributed, so using a t-distribution

t.test(tdata.wide$lakes, tdata.wide$reservoir, paired=TRUE)
# t = -0.72529, df = 54, p-value = 0.4715 (for 1 m depth)
# t = -0.97688, df = 18, p = 0.3416 (for 5 m depth)

# Now, plot! 
library(ggplot2)
# first, prep the data
tdata.long <- melt(tdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="tempmean")
tdata.long <- tdata.long[complete.cases(tdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
t.plot <- ggplot(tdata.long, aes(x=type, y=tempmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab(expression('Temp at 1m ('^o*'C)')) +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
tempp<-t.plot +   annotate(geom = "text", label = "p = 0.47", x=1.5, y=32, size=4)

##################################################
# temperature (bottom) #
##################################################

# Part 1. temperatures
temp <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_temp.csv") #temp data

res.temp<- subset(temp, SITE_ID %in% res.names)
lakes.temp <- subset(temp, SITE_ID %in% lakes.names)


# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.tempmean.bot <- ddply(res.temp, .(SITE_ID), summarize,
                      tempmean = min(TEMP_FIELD))
res.tempmean.bot$type <- rep("reservoir")
lakes.tempmean.bot <- ddply(lakes.temp, .(SITE_ID), summarize,
                        tempmean = min(TEMP_FIELD))
lakes.tempmean.bot$type <- rep("lakes")

# combine temp datasets into one long dataframe
ctemp <- rbind(res.tempmean.bot, lakes.tempmean.bot)

# Combine all info into one dataframe
tdatab <- merge(pairs, ctemp, by="SITE_ID")

# Cast data to wide for stats comparisons
tdata.wide <- dcast(tdatab, PAIR_ID ~ type, value.var = "tempmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
tdata.wide$x <- tdata.wide$lakes - tdata.wide$reservoir
boxplot(tdata.wide$x)
qqnorm(tdata.wide$x)
qqline(tdata.wide$x)
shapiro.test(tdata.wide$x) 
# Normally distributed, so using a t-distribution

t.test(tdata.wide$lakes, tdata.wide$reservoir, paired=TRUE)
# t = -0.72529, df = 54, p-value = 0.4715 (for 1 m depth)
# t = -0.97688, df = 18, p = 0.3416 (for 5 m depth)
# t = -3.2044, df=64, p=0.002 (for bottom depth.. minimum temp)
# Now, plot! 
library(ggplot2)
# first, prep the data
tbdata.long <- melt(tdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="tempmean")
tbdata.long <- tbdata.long[complete.cases(tbdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
t.plot <- ggplot(tbdata.long, aes(x=type, y=tempmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab(expression('Bottom Temp ('^o*'C)')) +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
tempbp<-t.plot +   annotate(geom = "text", label = "p < 0.01", x=1.5, y=30, size=4)
########################################
# Catchment area : lake area- boxplots #
########################################

basin <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_basin.csv")
area <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv")
catch <- merge(basin, area, by = "SITE_ID") # only merges if SITE_ID is in both files

res.catch<- subset(catch, SITE_ID %in% res.names)
res.catch$type <- rep("reservoir")
lakes.catch <- subset(catch, SITE_ID %in% lakes.names)
lakes.catch$type <- rep("lake")

# combine temp datasets into one long dataframe
c.catch <- rbind(res.catch, lakes.catch)

# Combine all info into one dataframe
cdata <- merge(pairs, c.catch, by="SITE_ID")
cdata$CA_LA <- cdata$BASINAREA_KM2/cdata$LAKEAREA # lake area in km^2

# Cast data to wide for stats comparisons
# Using average here because some lakes listed multiple times.
cdata.wide <- dcast(cdata, PAIR_ID ~ type, value.var = "CA_LA", fun.aggregate = mean)

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
cdata.wide$x <- cdata.wide$lake - cdata.wide$reservoir
hist(cdata.wide$x)
boxplot(cdata.wide$x)
qqnorm(cdata.wide$x)
qqline(cdata.wide$x)
shapiro.test(cdata.wide$x) 
# Not-Normally distributed
# Wilcoxon Signed Rank Test
wilcox.test(cdata.wide$lake, cdata.wide$reservoir, paired=TRUE)
# V = 742, p-value = 0.0204

# Now, plot! 
library(ggplot2)
# first, prep the data
cdata.long <- melt(cdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="CA_LAratio")
cdata.long <- cdata.long[complete.cases(cdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
tapply(X = cdata.long$CA_LAratio, INDEX = cdata.long$type, FUN = mean)
c.plot <- ggplot(cdata.long, aes(x=type, y=CA_LAratio, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("CA : LA") +
  xlab("")+
  scale_x_discrete(breaks = c("lake", "reservoir"), 
                   labels = c("natural", "human made")) +
  scale_y_log10()
calap<-c.plot +   annotate(geom = "text", label = "p < 0.05", x=1.5, y=1800, size=4)

########################################
# Catchment area  #
########################################

basin <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_basin.csv")
area <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv")
catch <- merge(basin, area, by = "SITE_ID") # only merges if SITE_ID is in both files

res.catch<- subset(catch, SITE_ID %in% res.names)
res.catch$type <- rep("reservoir")
lakes.catch <- subset(catch, SITE_ID %in% lakes.names)
lakes.catch$type <- rep("lake")

# combine catchment datasets into one long dataframe
c.catch <- rbind(res.catch, lakes.catch)

# Combine all info into one dataframe
cdata <- merge(pairs, c.catch, by="SITE_ID")
cdata$CA <- cdata$BASINAREA_KM2 # catcment area in km^2

# Cast data to wide for stats comparisons
# Using average here because some lakes listed multiple times.
cdata.wide <- dcast(cdata, PAIR_ID ~ type, value.var = "CA", fun.aggregate = mean)

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
cdata.wide$x <- cdata.wide$lake - cdata.wide$reservoir
hist(cdata.wide$x)
boxplot(cdata.wide$x)
qqnorm(cdata.wide$x)
qqline(cdata.wide$x)
shapiro.test(cdata.wide$x) 
# Not-Normally distributed
# Wilcoxon Signed Rank Test
wilcox.test(cdata.wide$lake, cdata.wide$reservoir, paired=TRUE)
# V = 570, p-value = 0.0006

# Now, plot! 
library(ggplot2)
# first, prep the data
cdata.long <- melt(cdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="CA")
cdata.long <- cdata.long[complete.cases(cdata.long),] # I don't know why incomplete cases are generated, but this gets rid of them
tapply(X = cdata.long$CA, INDEX = cdata.long$type, FUN = mean)
c.plot <- ggplot(cdata.long, aes(x=type, y=CA, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Catchment Area") +
  xlab("")+
  scale_x_discrete(breaks = c("lake", "reservoir"), 
                   labels = c("natural", "human made")) +
  scale_y_log10()
cap<-c.plot +   annotate(geom = "text", label = "p < 0.001", x=1.5, y=10000, size=4)


##################################################
# perimeter #
##################################################

# Part 1. perimeter
perim <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv") #perimeter data

res.perim<- subset(perim, SITE_ID %in% res.names)
lakes.perim <- subset(perim, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.perimean <- ddply(res.perim, .(SITE_ID), summarize,
                      perimean = mean(LAKEPERIM))
res.perimean$type <- rep("reservoir")
lakes.perimean <- ddply(lakes.perim, .(SITE_ID), summarize,
                        perimean = mean(LAKEPERIM))
lakes.perimean$type <- rep("lakes")

# combine perimeter datasets into one long dataframe
cperim <- rbind(res.perimean, lakes.perimean)

# Combine all info into one dataframe
pdata <- merge(pairs, cperim, by="SITE_ID")

# Cast data to wide for stats comparisons
pdata.wide <- dcast(pdata, PAIR_ID ~ type, value.var = "perimean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
pdata.wide$x <- pdata.wide$lakes - pdata.wide$reservoir
boxplot(pdata.wide$x)
qqnorm(pdata.wide$x)
qqline(pdata.wide$x)
shapiro.test(pdata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(pdata.wide$lakes, pdata.wide$reservoir, paired=TRUE)
# V=593, p= 0.001073
mean(pdata.wide$lakes)
mean(pdata.wide$reservoir)

# Now, plot! 
library(ggplot2)
# first, prep the data
pdata.long <- melt(pdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="perimean")
p.plot <- ggplot(pdata.long, aes(x=type, y=perimean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Perimeter (m)") +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))+
  scale_y_log10()
perimeterp<-p.plot +   annotate(geom = "text", label = "p < 0.01", x=1.5, y=500, size=4)

##################################################
# percent developed #
##################################################

# Part 1. percent developed
developed <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_basin.csv") #land use data

res.dev<- subset(developed, SITE_ID %in% res.names)
lakes.dev <- subset(developed, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.devmean <- ddply(res.dev, .(SITE_ID), summarize,
                      devmean = mean(PCT_DEVELOPED_BSN))
res.devmean$type <- rep("reservoir")
lakes.devmean <- ddply(lakes.dev, .(SITE_ID), summarize,
                        devmean = mean(PCT_DEVELOPED_BSN))
lakes.devmean$type <- rep("lakes")

# combine land use datasets into one long dataframe
deperim <- rbind(res.devmean, lakes.devmean)

# Combine all info into one dataframe
ddata <- merge(pairs, deperim, by="SITE_ID")

# Cast data to wide for stats comparisons
ddata.wide <- dcast(ddata, PAIR_ID ~ type, value.var = "devmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
ddata.wide$x <- ddata.wide$lakes - ddata.wide$reservoir
boxplot(ddata.wide$x)
qqnorm(ddata.wide$x)
qqline(ddata.wide$x)
shapiro.test(ddata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(ddata.wide$lakes, ddata.wide$reservoir, paired=TRUE)
# V=593, p= 0.27

# Now, plot! 
library(ggplot2)
# first, prep the data
ddata.long <- melt(ddata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="devmean")
p.plot <- ggplot(ddata.long, aes(x=type, y=devmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("% Developed") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
developedp<-p.plot +   annotate(geom = "text", label = "p =0.27", x=2.15, y=15, size=4)

##################################################
# elevation #
##################################################

# Part 1. elevation
elevation <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv") #elevation data

res.elev<- subset(elevation, SITE_ID %in% res.names)
lakes.elev <- subset(elevation, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.elevmean <- ddply(res.elev, .(SITE_ID), summarize,
                     elevmean = mean(ELEV_PT))
res.elevmean$type <- rep("reservoir")
lakes.elevmean <- ddply(lakes.elev, .(SITE_ID), summarize,
                       elevmean = mean(ELEV_PT))
lakes.elevmean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
eleva <- rbind(res.elevmean, lakes.elevmean)

# Combine all info into one dataframe
edata <- merge(pairs, eleva, by="SITE_ID")

# Cast data to wide for stats comparisons
edata.wide <- dcast(edata, PAIR_ID ~ type, value.var = "elevmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
edata.wide$x <- edata.wide$lakes - edata.wide$reservoir
boxplot(edata.wide$x)
qqnorm(edata.wide$x)
qqline(edata.wide$x)
shapiro.test(edata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(edata.wide$lakes, edata.wide$reservoir, paired=TRUE)
# V=593, p= 0.03

# Now, plot! 
library(ggplot2)
# first, prep the data
edata.long <- melt(edata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="elevmean")
e.plot <- ggplot(edata.long, aes(x=type, y=elevmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Elevation (m)") +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
elevationp<-e.plot +   annotate(geom = "text", label = "p < 0.05", x=1.5, y=3600, size=4)

##################################################
# area #
##################################################

# Part 1. area
area <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv") #area data

res.area<- subset(area, SITE_ID %in% res.names)
lakes.area <- subset(area, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.areamean <- ddply(res.area, .(SITE_ID), summarize,
                      areamean = mean(LAKEAREA))
res.areamean$type <- rep("reservoir")
lakes.areamean <- ddply(lakes.area, .(SITE_ID), summarize,
                        areamean = mean(LAKEAREA))
lakes.areamean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
areal <- rbind(res.areamean, lakes.areamean)

# Combine all info into one dataframe
adata <- merge(pairs, areal, by="SITE_ID")

# Cast data to wide for stats comparisons
adata.wide <- dcast(adata, PAIR_ID ~ type, value.var = "areamean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
adata.wide$x <- adata.wide$lakes - adata.wide$reservoir
boxplot(adata.wide$x)
qqnorm(adata.wide$x)
qqline(adata.wide$x)
shapiro.test(adata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(adata.wide$lakes, adata.wide$reservoir, paired=TRUE)
# V=791, p= 0.045
mean(adata.wide$lakes)
#6.179424... but median is 0.409
mean(adata.wide$reservoir)
#5.196161... but median is 0.711

# Now, plot! 
library(ggplot2)
# first, prep the data
adata.long <- melt(adata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="areamean")
a.plot <- ggplot(adata.long, aes(x=type, y=areamean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Area") +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))+
scale_y_log10()
areap<-a.plot +   annotate(geom = "text", label = "p < 0.05", x=1.5, y=140, size=4)


##################################################
# depth #
##################################################

# Part 1. depth
depth <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_lakes.csv") #depth data

res.dep<- subset(depth, SITE_ID %in% res.names)
lakes.dep <- subset(depth, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.depmean <- ddply(res.dep, .(SITE_ID), summarize,
                      depmean = mean(DEPTHMAX))
res.depmean$type <- rep("reservoir")
lakes.depmean <- ddply(lakes.dep, .(SITE_ID), summarize,
                        depmean = mean(DEPTHMAX))
lakes.depmean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
depthm <- rbind(res.depmean, lakes.depmean)

# Combine all info into one dataframe
dedata <- merge(pairs, depthm, by="SITE_ID")

# Cast data to wide for stats comparisons
dedata.wide <- dcast(dedata, PAIR_ID ~ type, value.var = "depmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
dedata.wide$x <- dedata.wide$lakes - dedata.wide$reservoir
boxplot(dedata.wide$x)
qqnorm(dedata.wide$x)
qqline(dedata.wide$x)
shapiro.test(dedata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(dedata.wide$lakes, dedata.wide$reservoir, paired=TRUE)
# V=1253, p= 0.35
mean(dedata.wide$lakes)
#10.7
mean(dedata.wide$reservoir)
#8.7

# Now, plot! 
library(ggplot2)
# first, prep the data
dedata.long <- melt(dedata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="depmean")
de.plot <- ggplot(dedata.long, aes(x=type, y=depmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Max Depth (m)") +
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
depthp<-de.plot +   annotate(geom = "text", label = "p = 0.35", x=1.5, y=50, size=4)

##################################################
# Depth Normalized Temperature Gradient #
##################################################

head(tdata)
head(dedata)
head(tdatab)
gradient<-merge(tdata,dedata,by.x="SITE_ID",by.y="SITE_ID")
gradient2<-merge(gradient,tdatab,by.x="SITE_ID",by.y="SITE_ID")
#tempmean.x is surface temp
#tempmean.y is bottom temp

# Combine all info into one dataframe
gradient2$surbot<-(gradient2$tempmean.x-gradient2$tempmean.y)
gradient2$tgrad <- (gradient2$surbot/gradient2$depmean)# degrees C per m depth

# Cast data to wide for stats comparisons
gradient.wide <- dcast(gradient2, PAIR_ID ~ type, value.var = "tgrad")
gradient.wide<-na.omit(gradient.wide)

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
gradient.wide$x <- gradient.wide$lakes - gradient.wide$reservoir
boxplot(gradient.wide$x)
qqnorm(gradient.wide$x)
qqline(gradient.wide$x)
shapiro.test(gradient.wide$x) 
# normally distributed
# t-test
t.test(gradient.wide$lakes, gradient.wide$reservoir, paired=TRUE)
# t=1.6471, p= 0.1055, df=53
mean(gradient.wide$lakes)
#0.77
mean(gradient.wide$reservoir)
#0.57

# Now, plot! 
library(ggplot2)
# first, prep the data
gradient.long <- melt(gradient.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="tempdep")
tede.plot <- ggplot(gradient.long, aes(x=type, y=tempdep, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab(expression('Temp Gradient ('^o*'C/m)'))
  xlab("")+
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
tedep<-tede.plot +   annotate(geom = "text", label = "p = 0.11", x=1.5, y=3, size=4)

########################################################
##      Code for making a multi-panel plot            ##
########################################################

multiplot<- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

multiplot(areap,elevationp,depthp,tempp,tedep,cap,perimeterp,secchip,tempbp,calap,cols=2)

##############################################################
# generate a table of statistics for the data                #
##############################################################

#first create a series of dataframes with matching column labels
A<-mutate(dedata.long,variable="depth")
A<-mutate(A,value=depmean)
A<-select(A,type,variable,value)
head(A)

B<-mutate(sdata.long,variable="secchi")
B<-mutate(B,value=secmean)
B<-select(B,type,variable,value)
head(B)

C<-mutate(adata.long,variable="area")
C<-mutate(C,value=areamean)
C<-select(C,type,variable,value)
head(C)

D<-mutate(edata.long,variable="elevation")
D<-mutate(D,value=elevmean)
D<-select(D,type,variable,value)
head(D)

E<-mutate(pdata.long,variable="perimeter")
E<-mutate(E,value=perimean)
E<-select(E,type,variable,value)
head(E)

I<-mutate(cdata.long,variable="CA:LA")
I<-mutate(I,value=CA_LAratio)
I<-select(I,type,variable,value)
head(I)

G<-mutate(tbdata.long,variable="bottom temp")
G<-mutate(G,value=tempmean)
G<-select(G,type,variable,value)
head(G)

H<-mutate(tdata.long,variable="temp at 1m")
H<-mutate(H,value=tempmean)
H<-select(H,type,variable,value)
head(H)

#now combine the data sets into one large dataframe
Z<-bind_rows(A,B)
Y<-bind_rows(Z,C)
X<-bind_rows(Y,D)
W<-bind_rows(X,E)
V<-bind_rows(W,I)
U<-bind_rows(V,G)
S<-bind_rows(U,H)

head(S)

#now generate summary table
library(plyr)
table<-ddply(S, .(type,variable),summarize,
             avg=mean(value,na.rm=TRUE),
             std=sd(value,na.rm=TRUE),
             med=median(value,na.rm=TRUE)
             )
table
write.table(table,"~/Desktop/EcoDAS_WIR/Figures/Summary_Table.csv",sep="\t")
##############################################################
# scatter plot of secchi disk by catchment area : lake area  #
# with distintion between man-made and natural lake          #
##############################################################

# Merge needed data files
sec_CALA <- merge(secchi, catch, by = "SITE_ID")

# Subset pairs of lakes and add identifier
res.sc<- subset(sec_CALA, SITE_ID %in% res.names)
res.sc$type <- rep("reservoir")
lakes.sc <- subset(sec_CALA, SITE_ID %in% lakes.names)
lakes.sc$type <- rep("lake")

# combine datasets into one long dataframe
sc.catch <- rbind(res.sc, lakes.sc)

# Combine all info into one dataframe
scdata <- merge(pairs, sc.catch, by="SITE_ID")
scdata$CA_LA <- scdata$BASINAREA_KM2/scdata$LAKEAREA # lake area in km^2

# ANOVA of Secchi and CA_LA across all sites
library(lme4)
mod <- lmer(SECMEAN ~ CA_LA + (1|PAIR_ID), data=scdata)
summary(mod)
anova(mod)

# Now, plot! 
library(ggplot2)
sc.plot <- ggplot(scdata, aes(x=CA_LA, y=SECMEAN, group=PAIR_ID)) +
  geom_point() +
  theme_classic(14) +
  scale_y_log10() +
  scale_x_log10() +
  geom_line(alpha=0.5)
sc.plot 

##################################################
# chlorophyll #
##################################################

# Part 1. chlorophyll
chla <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_chem.csv") #depth data

res.chla<- subset(chla, SITE_ID %in% res.names)
lakes.chla <- subset(chla, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.chlamean <- ddply(res.chla, .(SITE_ID), summarize,
                     chlamean = mean(CHLA))
res.chlamean$type <- rep("reservoir")
lakes.chlamean <- ddply(lakes.chla, .(SITE_ID), summarize,
                       chlamean = mean(CHLA))
lakes.chlamean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
chl <- rbind(res.chlamean, lakes.chlamean)

# Combine all info into one dataframe
cdata <- merge(pairs, chl, by="SITE_ID")

# Cast data to wide for stats comparisons
cdata.wide <- dcast(cdata, PAIR_ID ~ type, value.var = "chlamean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
cdata.wide$x <- cdata.wide$lakes - cdata.wide$reservoir
boxplot(cdata.wide$x)
qqnorm(cdata.wide$x)
qqline(cdata.wide$x)
shapiro.test(cdata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(cdata.wide$lakes, cdata.wide$reservoir, paired=TRUE)
# V=852, p= 0.15
mean(cdata.wide$lakes)
#NA
mean(cdata.wide$reservoir)
#30

# Now, plot! 
library(ggplot2)
# first, prep the data
cdata.long <- melt(cdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="chlamean")
cdata.long <- cdata.long[complete.cases(cdata.long),]
c.plot <- ggplot(cdata.long, aes(x=type, y=chlamean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Chlorophyll a") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
c.plot +   annotate(geom = "text", label = "p =0.15", x=2.15, y=15, size=4)


##################################################
# turbidity #
##################################################

# Part 1. chlorophyll
chla <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_chem.csv") #turbidity data

res.chla<- subset(chla, SITE_ID %in% res.names)
lakes.chla <- subset(chla, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.chlamean <- ddply(res.chla, .(SITE_ID), summarize,
                      chlamean = mean(TURB))
res.chlamean$type <- rep("reservoir")
lakes.chlamean <- ddply(lakes.chla, .(SITE_ID), summarize,
                        chlamean = mean(TURB))
lakes.chlamean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
chl <- rbind(res.chlamean, lakes.chlamean)

# Combine all info into one dataframe
cdata <- merge(pairs, chl, by="SITE_ID")

# Cast data to wide for stats comparisons
cdata.wide <- dcast(cdata, PAIR_ID ~ type, value.var = "chlamean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
cdata.wide$x <- cdata.wide$lakes - cdata.wide$reservoir
boxplot(cdata.wide$x)
qqnorm(cdata.wide$x)
qqline(cdata.wide$x)
shapiro.test(cdata.wide$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(cdata.wide$lakes, cdata.wide$reservoir, paired=TRUE)
# V=868, p= 0.13
mean(cdata.wide$lakes)
#NA
mean(cdata.wide$reservoir)
#6.73

# Now, plot! 
library(ggplot2)
# first, prep the data
cdata.long <- melt(cdata.wide[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="chlamean")
cdata.long <- cdata.long[complete.cases(cdata.long),]
c.plot <- ggplot(cdata.long, aes(x=type, y=chlamean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("Turbidity") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
c.plot +   annotate(geom = "text", label = "p =0.13", x=2.15, y=15, size=4)

##################################################
# DOC #
##################################################

# Part 1. DOC
doc <- read.csv("~/Desktop/EcoDAS_WIR/Data/NLA2007_chem.csv") #turbidity data

res.doc<- subset(doc, SITE_ID %in% res.names)
lakes.doc <- subset(doc, SITE_ID %in% lakes.names)

# there are multiple records of temp for some sites
# so, taking average of multiple readings
library(plyr)
library(reshape2)
res.docmean <- ddply(res.doc, .(SITE_ID), summarize,
                      docmean = mean(DOC))
res.docmean$type <- rep("reservoir")
lakes.docmean <- ddply(lakes.doc, .(SITE_ID), summarize,
                        docmean = mean(DOC))
lakes.docmean$type <- rep("lakes")

# combine elevation datasets into one long dataframe
doca <- rbind(res.docmean, lakes.docmean)

# Combine all info into one dataframe
docdata <- merge(pairs, doca, by="SITE_ID")

# Cast data to wide for stats comparisons
docdata.wide <- dcast(docdata, PAIR_ID ~ type, value.var = "docmean")

# Statistical comparison of secchi depths using Paired T-test
# First, check for normality
docdata.wide$x <- docdata.wide$lakes - docdata.wide$reservoir
boxplot(docdata.wide$x)
qqnorm(docdata.wide$x)
qqline(docdata.wide$x)
shapiro.test(docdata.wide$x)
# outlier in the data, drop from dataset
docdata.out <- docdata.wide[(docdata.wide$x < 60), ]
# Now, check
boxplot(docdata.out$x)
qqnorm(docdata.out$x)
qqline(docdata.out$x)
# outlier in the data, drop from dataset
docdata.outb <- docdata.out[(docdata.out$x > -20), ]
shapiro.test(docdata.outb$x) 
# not normally distributed. Therefore, non-param test
# Wilcoxon Signed Rank Test
wilcox.test(docdata.outb$lakes, docdata.outb$reservoir, paired=TRUE)
# V=1112, p= 0.97
mean(docdata.outb$lakes)
#7.8
mean(docdata.outb$reservoir)
#6.5

# Now, plot! 
library(ggplot2)
# first, prep the data
docdata.long <- melt(docdata.outb[,1:3], id.vars="PAIR_ID", variable.name = "type", value.name="docmean")
doccdata.long <- doccdata.long[complete.cases(docdata.long),]
doc.plot <- ggplot(docdata.long, aes(x=type, y=docmean, group=PAIR_ID)) +
  geom_line(alpha=0.5) +
  geom_point() +
  theme_classic(14) +
  ylab("DOC") +
  scale_x_discrete(breaks = c("lakes", "reservoir"), 
                   labels = c("natural", "human made"))
doc.plot +   annotate(geom = "text", label = "p =0.97", x=2.15, y=15, size=4)


